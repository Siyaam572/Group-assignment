# -*- coding: utf-8 -*-
"""Data Preparation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-01H5u_7WZ3QRAPbnw-9GLkGkvCvMaga

#**DATA PREPARATION**

Load Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""# **Demand Dataset**"""

from google.colab import drive
drive.mount('/content/gdrive')

demand=pd.read_csv('/content/gdrive/MyDrive/Advanced Data Analytics/Datasets/demand.csv', keep_default_na=False, na_values=[''])
#read the excel file
#prevent pandas from reading NA as null
#keep the empty values as null

demand

"""Data Preprocessing steps"""

demand.info() #get information about the dataset

#dealing with issue of NA
#convert NA to NORAM
demand['DF_region'] = demand['DF_region'].replace('NA', 'NORAM')
demand

#Get number of rows and Columns
demand.shape

#Clean missing values
print("These are the missing values for each attribute.")
display(demand.isna().sum())

# Identify numerical columns (DF1 to DF12)
df_columns = [col for col in demand.columns if col.startswith('DF') and demand[col].dtype == 'float64']

# Determine the number of rows and columns for the subplot grid
num_cols = len(df_columns)
num_rows = (num_cols + 2) // 3 # Roughly 3 columns per row

plt.figure(figsize=(18, num_rows * 5))

for i, col in enumerate(df_columns):
    plt.subplot(num_rows, 3, i + 1) # Create subplots in a grid
    plt.boxplot(demand[col].dropna())
    plt.title(f'Box Plot of {col}')
    plt.ylabel('')

plt.tight_layout()
plt.show()

#filling the missing values with median because they are more robust to ouliers
for col in demand.columns:
    if demand[col].dtype == 'float64' and demand[col].isnull().any():
        median_val = demand[col].median()
        demand[col] = demand[col].fillna(median_val)

print("Missing values after filling with median:")
display(demand.isna().sum())

"""# **Plants Data**"""

plants=pd.read_csv('/content/gdrive/MyDrive/Advanced Data Analytics/Datasets/plants.csv', keep_default_na=False, na_values=[''])
#read the excel file
#prevent pandas from reading NA as null
#keep the empty values as null

plants

#dealing with issue of NA
#convert NA to NORAM
plants['Region'] = plants['Region'].replace('NA', 'NORAM')
plants

plants.shape

#Clean missing values
print("These are the missing values for each attribute.")
display(plants.isna().sum())

"""# **Generation Costs**"""

generation_costs=pd.read_csv('/content/gdrive/MyDrive/Advanced Data Analytics/Datasets/generation_costs.csv')
#read the excel file

generation_costs

generation_costs.shape

#Clean missing values
print("These are the missing values for each attribute.")
display(generation_costs.isna().sum())

#Replacing missing values in generation costs dataset with median
median_cost = generation_costs['Cost_USD_per_MWh'].median()
generation_costs['Cost_USD_per_MWh'] = generation_costs['Cost_USD_per_MWh'].fillna(median_cost)
print("Missing values in generation_costs after median imputation:")
display(generation_costs.isna().sum())

"""# Removing Worst Performing Plants

Calculate Average Cost per Plant
"""

#Calculate the mean cost for each plant
avg_plant_costs = generation_costs.groupby('Plant ID')['Cost_USD_per_MWh'].mean().reset_index()
print("Average cost per plant:")
display(avg_plant_costs.head())

#sort plants by average cost
sorted_avg_plant_costs = avg_plant_costs.sort_values(by='Cost_USD_per_MWh', ascending=True).reset_index(drop=True)
print("Top 5 cheapest plants:")
display(sorted_avg_plant_costs.head(5))

print("\nTop 5 most expensive plants:")
display(sorted_avg_plant_costs.tail(5))

#bar chart to show the average cost per plan and the overall median average cost
plt.figure(figsize=(15, 7))
plt.bar(avg_plant_costs['Plant ID'], avg_plant_costs['Cost_USD_per_MWh'], color='skyblue')

median_avg_cost = avg_plant_costs['Cost_USD_per_MWh'].median()
plt.axhline(y=median_avg_cost, color='r', linestyle='--', label=f'Overall Median Average Cost: {median_avg_cost:.2f}')

plt.xlabel('Plant ID')
plt.ylabel('Average Cost (USD per MWh)')
plt.title('Average Generation Cost per Plant with Overall Median')
plt.xticks(rotation=90)
plt.legend()
plt.grid(axis='y', linestyle='--')
plt.tight_layout()
plt.show()

"""
For each demand scenario, which plant has the minimum cost
"""

#cheapest plant for each demand scenario
cheapest_plants_per_demand = generation_costs.loc[generation_costs.groupby('Demand ID')['Cost_USD_per_MWh'].idxmin()][['Demand ID', 'Plant ID', 'Cost_USD_per_MWh']]
print("Cheapest plants for each demand scenario:")
display(cheapest_plants_per_demand.head())

#how many times is this plant the cheapest option
plant_wins = cheapest_plants_per_demand['Plant ID'].value_counts().reset_index()
plant_wins.columns = ['Plant ID', 'Win Count']

#top 10 cheapest plants often
print("Top 10 plants that are most often the cheapest option:")
display(plant_wins.head(10))

#identify plants that never win
all_plants = set(plants['Plant ID'].unique())
winning_plants = set(plant_wins['Plant ID'].unique())

never_winning_plants = list(all_plants - winning_plants)

print("Plants that never were the cheapest option:")
display(never_winning_plants)

"""Identify top 10 cheapest plants per demand"""

#top 10 cheapest plants by demand
top_10_cheapest_plants_per_demand = generation_costs.sort_values(by=['Demand ID', 'Cost_USD_per_MWh']).groupby('Demand ID').head(10)
print("Top 10 cheapest plants per demand scenario:")
display(top_10_cheapest_plants_per_demand.head(20))

#how many times do these top 10 appear in the top 10 for all demand scenarios list we created before
plant_appearances_in_top10 = top_10_cheapest_plants_per_demand['Plant ID'].value_counts().reset_index()
plant_appearances_in_top10.columns = ['Plant ID', 'Appearance Count']
print("Count of times each plant appeared in the top 10 cheapest list:")
display(plant_appearances_in_top10.head(10))

#plants that didnt appear on any list
all_plants_ids = set(plants['Plant ID'].unique())
plants_in_top10 = set(plant_appearances_in_top10['Plant ID'].unique())

never_in_top10_plants = list(all_plants_ids - plants_in_top10)

print("Plants that never appeared in the top 10 cheapest list:")
display(never_in_top10_plants)

print(f"Total number of plants that never appeared in the top 10 cheapest list: {len(never_in_top10_plants)}")

"""Visualizing this"""

# Create a figure with 4 subplots (2 rows, 2 columns)
fig, axes = plt.subplots(2, 2, figsize=(20, 15))
fig.suptitle('Plant Performance Analysis', fontsize=20)

# Plot 1 (top-left): Bar chart showing number of times each plant WINS (is the best choice)
# Ensure plant_wins is sorted for ranking
plant_wins_sorted = plant_wins.sort_values(by='Win Count', ascending=False)
sns.barplot(x='Plant ID', y='Win Count', data=plant_wins_sorted, ax=axes[0, 0], color='green')
axes[0, 0].set_title('Number of Times Each Plant is the Cheapest Option')
axes[0, 0].set_xlabel('Plant ID (Ranked)')
axes[0, 0].set_ylabel('Number of Wins')
axes[0, 0].tick_params(axis='x', rotation=90)

# Plot 2 (top-right): Bar chart showing number of times each plant is in TOP 10
# Ensure plant_appearances_in_top10 is sorted for ranking
plant_appearances_sorted = plant_appearances_in_top10.sort_values(by='Appearance Count', ascending=False)
sns.barplot(x='Plant ID', y='Appearance Count', data=plant_appearances_sorted, ax=axes[0, 1], color='orange')
axes[0, 1].set_title('Number of Times Each Plant is in Top 10 Cheapest')
axes[0, 1].set_xlabel('Plant ID (Ranked)')
axes[0, 1].set_ylabel('Times in Top 10')
axes[0, 1].tick_params(axis='x', rotation=90)

# Plot 3 (bottom-left): Histogram of average costs across all plants
median_avg_cost = sorted_avg_plant_costs['Cost_USD_per_MWh'].median()
sns.histplot(sorted_avg_plant_costs['Cost_USD_per_MWh'], kde=True, ax=axes[1, 0], color='blue')
axes[1, 0].axvline(median_avg_cost, color='red', linestyle='--', label=f'Median: {median_avg_cost:.2f}')
axes[1, 0].set_title('Distribution of Average Plant Costs')
axes[1, 0].set_xlabel('Average Cost (USD/MWh)')
axes[1, 0].set_ylabel('Number of Plants')
axes[1, 0].legend()

# Plot 4 (bottom-right): Scatter plot - Average cost of each plant vs. Number of times that plant is in top 10
# Merge dataframes to get both average cost and top 10 count for each plant
merged_data = pd.merge(sorted_avg_plant_costs, plant_appearances_in_top10, on='Plant ID', how='left')
merged_data['Appearance Count'] = merged_data['Appearance Count'].fillna(0) # Fill NaN for plants never in top 10
sns.scatterplot(x='Cost_USD_per_MWh', y='Appearance Count', data=merged_data, ax=axes[1, 1], hue='Plant ID', legend=False)
axes[1, 1].set_title('Average Cost vs. Top 10 Appearance Count')
axes[1, 1].set_xlabel('Average Cost (USD/MWh)')
axes[1, 1].set_ylabel('Times in Top 10')

plt.tight_layout(rect=[0, 0.03, 1, 0.96]) # Adjust layout to prevent suptitle overlap
plt.show()

"""## Create list of plants to keep

"""

#create a list to keep plants that appeared in the top 10 cheapest at least once
plants_to_keep = plant_appearances_in_top10['Plant ID'].tolist()
print("Some of the plants in the 'plants_to_keep' list:")
display(plants_to_keep[:5])

"""## Calculate plant counts and removal percentage


"""

original_plant_count = plants['Plant ID'].nunique()
plants_to_keep_count = len(plants_to_keep)
plants_to_remove_count = original_plant_count - plants_to_keep_count
removal_percentage = (plants_to_remove_count / original_plant_count) * 100

print(f"Original number of plants: {original_plant_count}")
print(f"Number of plants to keep: {plants_to_keep_count}")
print(f"Number of plants to remove: {plants_to_remove_count}")
print(f"Percentage of plants to be removed: {removal_percentage:.2f}%")

# Print shapes before filtering
print("Shapes before filtering:")
print(f"plants: {plants.shape}")
print(f"generation_costs: {generation_costs.shape}")
print(f"demand: {demand.shape}\n")

# Filter plants and generation_costs DataFrames
filtered_plants = plants[plants['Plant ID'].isin(plants_to_keep)]
filtered_generation_costs = generation_costs[generation_costs['Plant ID'].isin(plants_to_keep)]

# Demand DataFrame remains unchanged
filtered_demand = demand.copy()

# Print shapes after filtering
print("Shapes after filtering:")
print(f"filtered_plants: {filtered_plants.shape}")
print(f"filtered_generation_costs: {filtered_generation_costs.shape}")
print(f"filtered_demand: {filtered_demand.shape}\n")

# Verify unique Plant IDs in filtered_generation_costs
unique_plants_in_filtered_costs = filtered_generation_costs['Plant ID'].nunique()
expected_unique_plants = len(plants_to_keep)

print(f"Unique Plant IDs in filtered_generation_costs: {unique_plants_in_filtered_costs}")
print(f"Expected unique Plant IDs (from plants_to_keep): {expected_unique_plants}")

"""## Saving Filtered DataFrames to CSV"""

# Define the output directory
output_dir = '/content/gdrive/MyDrive/Advanced Data Analytics/Datasets/Cleaned Datasets/'

# Save filtered_demand
filtered_demand.to_csv(output_dir + 'final_cleaned_demand.csv', index=False)
print(f"Filtered demand dataset saved to: {output_dir + 'final_cleaned_demand.csv'}")

# Save filtered_plants
filtered_plants.to_csv(output_dir + 'final_cleaned_plants.csv', index=False)
print(f"Filtered plants dataset saved to: {output_dir + 'final_cleaned_plants.csv'}")

# Save filtered_generation_costs
filtered_generation_costs.to_csv(output_dir + 'final_cleaned_generation_costs.csv', index=False)
print(f"Filtered generation_costs dataset saved to: {output_dir + 'final_cleaned_generation_costs.csv'}")



